name: "HNG-ACTIONS"
description: "A tool used in workflow script to automate the deployment of each pull request"

inputs:
  server_host:
    description: SSH host of the server
    required: true
  server_username: 
    description: SSH username 
    required: true
  server_password:
    description: SSH password 
    required: true
  server_port:
    description: SSH port
    required: true
  dir:
    description: Directory in the repository where the Dockerfile or start command is located
    default: "./"
  dockerfile:
    description: Path to the Dockerfile (optional)
    required: false
  start_command:
    description: Command to start the application if Dockerfile is not provided (optional)
    required: false
  compose_file:
    description: Path to the docker-compose.yml file (optional)
    required: false
  exposed_port:
    description: Port to expose in the container
    required: true
  env:
    description: Environment variables to pass to the container
    required: true
  branch_name:
    description: The branch name for the github repository that made a pull request
    required: true
  repo_url:
    description: The repository that made the pull request
    required: true
  pr_number:
    description: The pull request number for the trigger.
    required: true


# outputs:
#   status:
#     description: Status of the deployment
#     required: true

runs:
  using: 'composite'
  steps:
    - name: Set GitHub Path
      run: echo "$GITHUB_ACTION_PATH" >> $GITHUB_PATH
      shell: bash
      env:
        GITHUB_ACTION_PATH: ${{ github.action_path }}
    - name: Run entrypoint.sh
      env:
          GITHUB_ACTION_PATH: ${{ github.action_path }}
          SERVER_HOST: ${{ inputs.server_host }}
          SERVER_USERNAME: ${{ inputs.server_username }}
          SERVER_PASSWORD: ${{ inputs.server_password }}
          SERVER_PORT: ${{ inputs.server_port }}
          DIR: ${{ inputs.dir }}
          DOCKERFILE: ${{ inputs.dockerfile }}
          START_COMMAND: ${{ inputs.start_command }}
          COMPOSE_FILE: ${{ inputs.compose_file }}
          EXPOSED_PORT: ${{ inputs.exposed_port }}
          ENV_VARS: ${{ inputs.env }}
          REPO_URL: ${{ inputs.repo_url }}
          BRANCH_NAME: ${{ inputs.branch_name }}
          PR_NUMBER: ${{ inputs.pr_number }}
      run: |
             if [ -n "$SSH_PRIVATE_KEY" ]; then
              echo "$SSH_PRIVATE_KEY" > private_key.pem
              chmod 600 private_key.pem
              SSH_CMD="ssh -i private_key.pem -o StrictHostKeyChecking=no -p $PORT $USERNAME@$HOST"
            else
              SSH_CMD="sshpass -p $PASSWORD ssh -o StrictHostKeyChecking=no -p $PORT $USERNAME@$HOST"
            fi
        
            $SSH_CMD << EOF      
              if ! command -v docker &> /dev/null; then
                sudo apt-get update
                sudo apt-get install -y docker.io
              fi
    
              # Add current user to docker group
              # sudo usermod -aG docker $USER
              # newgrp docker
    
              # Loop through each container and stop and remove it
              CONTAINERS=$(sudo docker ps -aq --filter "label=branch=${GITHUB_HEAD_REF}")
              IMAGES=$(sudo docker images -q --filter "label=branch=${GITHUB_HEAD_REF}")
        
              for CONTAINER_ID in \$CONTAINERS; do
                  echo "Stopping and removing container \$CONTAINER_ID..."
                  sudo docker stop \$CONTAINER_ID
                  sudo docker rm -f \$CONTAINER_ID
              done
    
              for IMAGE_ID in \$IMAGES; do
                  echo "Removing image \$IMAGE_ID..."
                  sudo docker rmi -f \$IMAGE_ID
              done
    
            EOF
        
            if [ -n "$SSH_PRIVATE_KEY" ]; then
              sudo rm private_key.pem
            fi
      shell: bash
